**************************************************************************************************************************************************************

Daniel Bäckström and Martin Hermansson
Group 4

**************************************************************************************************************************************************************

1.

Setup:

S = statements of the program
Q = precondition
R = postcondition

What we want to prove:
Q ==> wp(S, R)

Q = True
R = (0 <= y && (0 <= x ==> y == x) && x < 0 ==> y == -x)

wp(S, R)
wp(if x < 0 then y := -x else y := x, R)
[Conditional rule]
(x < 0 ==> wp(y := -x, R)) && (!(x < 0) ==> wp(y := x, R))
[R = (0 <= y && (0 <= x ==> y == x) && x < 0 ==> y == -x)]
(x < 0 ==> wp(y := -x, (0 <= y && (0 <= x ==> y == x) && x < 0 ==> y == -x))) && (!(x < 0) ==> wp(y := x, (0 <= y && (0 <= x ==> y == x) && x < 0 ==> y == -x)))
[Assignment rule]
(x < 0 ==> (0 <= -x && (0 <= x ==> -x == x) && x < 0 ==> -x == -x)) && (x >= 0) ==> (0 <= x && (0 <= x ==> x == x) && x < 0 ==> x == -x))

Here we split up the expression and prove all to be correct:
A = (x < 0 ==> (0 <= -x && (0 <= x ==> -x == x) && x < 0 ==> -x == -x))
B = (x >= 0) ==> (0 <= x && (0 <= x ==> x == x) && x < 0 ==> x == -x))

Prove A && B from above:
	For A:
		x < 0 ==>
			0 <= -x <-- Trivially true
			&&
			(0 <= x ==> -x == x) <-- Since x must be smaller than 0 the LHS will always be false. Hence implication is true.
			&&
			x < 0 ==> -x == -x <-- Trivially true
	==> A is always true
	
	For B:
		x >= 0 ==>
			0 <= x <-- Trivially true
			&&
			(0 <= x ==> x == x) <-- Trivially true
			&&
			x < 0 ==> x == -x <-- Since x must be greater than 0 the LHS will always be false. Hence implication is true.
	==> B is always true
	
Since A && B are both true the method is proven to fulfill the postcondition R.

Q ==> wp(S, R)
True ==> True <-- Trivially true

**************************************************************************************************************************************************************

2a.

Setup:

S = statements of the program
Q = precondition
R = postcondition

What we want to prove:
Q ==> wp(S, R)

b = big
s = small
R = b > s

wp(S, R)
wp(if x > y then b := x; s := y else b := y; s := x, R)
[Conditional rule]
x > y ==> wp(b := x; s := y, R)         && !(x > y) ==> wp(b := y; s := x, R)
[Sequential rule]
x > y ==> wp(b := x, wp(s := y, R))     && !(x > y) ==> wp(b := y wp(s := x, R))
[R = b > s]
x > y ==> wp(b := x, wp(s := y, b > s)) && !(x > y) ==> wp(b := y wp(s := x, b > s))
[Assignment rule]
x > y ==> wp(b := x, b > y)             && !(x > y) ==> wp(b := y, b > x)
[Assignment rule]

x > y ==> x > y && !(x > y) ==> (y > x)
[Logic]
x > y ==> x > y && (x <= y) ==> (y > x)
[Commutativity]
x > y ==> x > y && (y => x) ==> (y > x)
|_____________|    |__________________|
       |                     |
      = A                   = B
A <-- Trivially true
B is false! A counter example would be if y == x. That does not imply that y > x.

True =/=> True && False

What the program misses is a precondition that x != y.

**************************************************************************************************************************************************************

2b.

Setup:

S = statements of the program
Q = precondition
R = postcondition

What we want to prove:
Q ==> wp(S, R)

b = big
s = small
Q = x != y
R = b > s

wp(S, R)
wp(if x != y; x > y then b := x && s := y else b := y; s := x, R)
[Conditional rule]
(x != y && x > y ==> wp(b := x; s := y, R))         && (x != y && !(x > y) ==> wp(b := y; s := x, R))
[Sequential rule]
(x != y && x > y ==> wp(b := x, wp(s := y, R)))     && (x != y && !(x > y) ==> wp(b := y wp(s := x, R)))
[R = b > s]
(x != y && x > y ==> wp(b := x, wp(s := y, b > s))) && (x != y && !(x > y) ==> wp(b := y wp(s := x, b > s)))
[Assignment rule]
(x != y && x > y ==> wp(b := x, b > y)              && (x != y && !(x > y) ==> wp(b := y, b > x))
[Assignment rule]

(x != y && x > y ==> x > y) && (x != y && !(x > y) ==> (y > x))
[Logic]
(x != y && x > y ==> x > y) && (x != y && (x <= y) ==> (y > x))
[If x != y and x <= y then x < y]
(x != y && x > y ==> x > y) && ((x < y) ==> (y > x))
|_________________________|    |______________________________|
             |                                 |
            = A                               = B
A <-- Trivially true
B <-- Trivially true

Since A && B are both true the method is proven to fulfill the postcondition R when x != y.

Q ==> wp(S, R)
x != y ==> True <-- Always true

**************************************************************************************************************************************************************

3b.

Setup:

S1, S = statements of the program
Q = precondition
R = postcondition
I = invariant
V = variant (decreases)

S1 = res := 0; IF n0 >= 0 THEN n := n0; m := m0 ELSE n := -n0; m := -m0
S = res := res + m; n := n - 1
Q = true
R = res == n0 * m0
I = 0 <= n && (n0 >= 0 ==> res == (n0 - n) * m) && (n0 < 0 ==> res == (-n0 - n) * m)
V = n


Let S1 be the statements before the while loop, S the statements inside the while loop.

This is what we want to prove for total correctness:
1)
Q ==> wp(S1, I)

To prove this wp(S1, I) must be true to fulfill the implication's truthiness.

Q ==> wp(res := 0; IF n0 >= 0 THEN n := n0; m := m0 ELSE n := -n0; m := -m0, I)
[Conditional rule]
Q ==> wp(res := 0; (n0 >= 0 ==> wp(n := n0; m := m0, I)) && (n0 < 0 ==> wp(n := -n0; m := -m0, I)))
[Sequential rule]
Q ==> wp(res := 0; (n0 >= 0 ==> wp(n := n0 wp(m := m0, I))) && (n0 < 0 ==> wp(n := -n0 wp(m := -m0, I))))
[Assign I its value]
Q ==> wp(res := 0; (n0 >= 0 ==> wp(n := n0 wp(m := m0, (0 <= n && (n0 >= 0 ==> res == (n0 - n) * m) && (n0 < 0 ==> res == (-n0 - n) * m))))) && (n0 < 0 ==> wp(n := -n0 wp(m := -m0, (0 <= n && (n0 >= 0 ==> res == (n0 - n) * m) && (n0 < 0 ==> res == (-n0 - n) * m))))))
[Assignment rule]
Q ==> wp(res := 0; (n0 >= 0 ==> wp(n := n0, (0 <= n && (n0 >= 0 ==> res == (n0 - n) * m0) && (n0 < 0 ==> res == (-n0 - n) * m0)))) && (n0 < 0 ==> wp(n := -n0, (0 <= n && (n0 >= 0 ==> res == (n0 - n) * -m0) && (n0 < 0 ==> res == (-n0 - n) * -m0)))))
[Assignment rule]
Q ==> wp(res := 0; (n0 >= 0 ==> (0 <= n0 && (n0 >= 0 ==> res == (n0 - n0) * m0) && (n0 < 0 ==> res == (-n0 - n0) * m0))) && (n0 < 0 ==> (0 <= -n0 && (n0 >= 0 ==> res == (n0 + n0) * -m0) && (n0 < 0 ==> res == (-n0 + n0) * -m0))))
[Assignment rule]
Q ==> (n0 >= 0 ==> (0 <= n0 && (n0 >= 0 ==> 0 == (n0 - n0) * m0) && (n0 < 0 ==> 0 == (-n0 - n0) * m0))) && (n0 < 0 ==> (0 <= -n0 && (n0 >= 0 ==> 0 == (n0 + n0) * -m0) && (n0 < 0 ==> 0 == (-n0 + n0) * -m0)))
[Simplify]
Q ==> (n0 >= 0 ==> (0 <= n0 && (n0 >= 0 ==> 0 == 0) && (n0 < 0 ==> 0 == -2 * n0 * m0))) && (n0 < 0 ==> (0 <= -n0 && (n0 >= 0 ==> 0 == 2 * n0 * -m0) && (n0 < 0 ==> 0 == 0)))
      |_______________________________________________________________________________|    |_______________________________________________________________________________|
	                                        |                                               	                                   |
										   true                                         &&                                        true
Q ==> true && true
[Simplify]
Q ==> true <-- Since Q = true this is trivially true

2)
I && B ==> wp(S, I)

3)
I && !B ==> R

4)
I && B ==> V > 0

5)
I && B ==> wp(V1 := V; S, V < V1)


**************************************************************************************************************************************************************

4b.


**************************************************************************************************************************************************************